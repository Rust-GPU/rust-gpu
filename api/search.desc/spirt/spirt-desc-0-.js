searchState.loadedDescShard("spirt", 0, "<code>SPIR-üáπ</code>\nAny semantic or non-semantic (debuginfo) ‚Ä¶\nInterned handle for an <code>AttrSetDef</code> (a set of <code>Attr</code>s).\nDefinition for an <code>AttrSet</code>: a set of <code>Attr</code>s.\nLinear chain of <code>DataInst</code>s, executing in sequence.\nTwo-case selection based on boolean condition, i.e. <code>if</code>-<code>else</code>‚Ä¶\nInterned handle for a <code>ConstDef</code> (a constant value).\nDefinition for a <code>Const</code>: a constant value.\nContext object with global resources for SPIR-T.\nEntity handle for a <code>ControlNodeDef</code> (a control-flow ‚Ä¶\nDefinition for a <code>ControlNode</code>: a control-flow operator or ‚Ä¶\nOne of the outputs produced by a <code>ControlNode</code>:\nEntity handle for a <code>ControlRegionDef</code> (a control-flow ‚Ä¶\nDefinition for a <code>ControlRegion</code>: a control-flow region.\nOne of the inputs to a <code>ControlRegion</code>:\nEntity handle for a <code>DataInstDef</code> (a leaf instruction).\nDefinition for a <code>DataInst</code>: a leaf (non-control-flow) ‚Ä¶\nInterned handle for a <code>DataInstFormDef</code> (a ‚Äúform‚Äù, or ‚Äú‚Ä¶\n‚ÄúForm‚Äù (or ‚Äútemplate‚Äù) definition for ‚Ä¶\nThe output value of a <code>DataInst</code>.\nDeclarations (<code>GlobalVarDecl</code>, <code>FuncDecl</code>) can contain a full ‚Ä¶\nA type holding enough different <code>Option&lt;V&gt;</code> slots, for all ‚Ä¶\nDiagnostics produced by SPIR-T passes, and recorded in ‚Ä¶\nThe ‚Äúseverity‚Äù level of a <code>Diag</code>nostic.\nOne part of a <code>Diag</code>nostic message, allowing rich ‚Ä¶\nCan be used anywhere to record <code>Diag</code>nostics produced during ‚Ä¶\nThe entity type that appears exactly once in every value ‚Ä¶\nCollection holding the actual definitions for <code>Context</code>‚Ä¶\nDoubly-linked list, ‚Äúintrusively‚Äù going through <code>E::Def</code>‚Ä¶\n<code>EntityList&lt;E&gt;</code> iterator, but with a different API than ‚Ä¶\nMap with <code>K</code> keys and <code>V</code> values, that is:\n<code>EntityOriented*Map&lt;Self, V&gt;</code> support trait, implemented for ‚Ä¶\nLeave the current invocation, similar to returning from ‚Ä¶\nAn unique identifier (e.g. a link name, or ‚Äúsymbol‚Äù) ‚Ä¶\nA definition exported out of a module (see also <code>ExportKey</code>).\nEntity handle for a <code>FuncDecl</code> (a function).\nDeclaration/definition for a <code>Func</code>: a function.\nThe body of a <code>Func</code> definition.\nEntity handle for a <code>GlobalVarDecl</code> (a global variable).\nDeclaration/definition for a <code>GlobalVar</code>: a global variable.\nThe body of a <code>GlobalVar</code> definition.\nPlaceholder for <code>GlobalVar</code>s with <code>GlobalVarShape::Handles</code>.\nAn identifier (e.g. a link name, or ‚Äúsymbol‚Äù) for an ‚Ä¶\nInterned handle for a <code>str</code>.\nExecute <code>body</code> repeatedly, until <code>repeat_condition</code> evaluates ‚Ä¶\nNon-semantic details (i.e. debuginfo) of a SPIR-Y module ‚Ä¶\nSemantic properties of a SPIR-T module (not tied to any ‚Ä¶\nWrapper to limit <code>Ord</code> for interned index types (e.g. ‚Ä¶\n<code>QPtr</code>-specific attributes (see <code>qptr::QPtrAttr</code>).\n‚ÄúQuasi-pointer‚Äù, an untyped pointer-like abstract ‚Ä¶\n<code>QPtr</code>-specific operations (see <code>qptr::QPtrOp</code>).\nChoose one <code>ControlRegion</code> out of <code>cases</code> to execute, based on ‚Ä¶\nSome SPIR-V instructions, like <code>OpFunction</code>, take a bitflags ‚Ä¶\nThe type of a <code>ConstKind::SpvStringLiteralForExtInst</code> ‚Ä¶\nSPIR-V <code>OpString</code>, but only when used as an operand for an ‚Ä¶\nInterned handle for a <code>TypeDef</code>.\nDefinition for a <code>Type</code>.\nThe address space the global variable will be allocated ‚Ä¶\nInsert all of <code>list_to_append</code>‚Äôs nodes at the end of <code>self</code>.\nStart immutably traversing the function at <code>position</code>.\nShorthand for <code>func_def_body.at(func_def_body.body)</code>.\nStart mutably traversing the function at <code>position</code>.\nShorthand for <code>func_def_body.at_mut(func_def_body.body)</code>.\nThe <code>ControlRegion</code> representing the whole body of the ‚Ä¶\nControl-flow graph (CFG) abstractions and utilities.\nTools for working with control-flow graphs that contain ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTraversal helpers for intra-function entities.\nReturn a custom <code>ExtInstSetDesc</code>, if one was registered on ‚Ä¶\nIf <code>Some</code>, the global variable will start out with the ‚Ä¶\nInputs to this <code>ControlRegion</code>:\nInsert <code>new_node</code> (defined in <code>defs</code>) into <code>self</code>, before <code>next</code>.\nInsert <code>new_node</code> (defined in <code>defs</code>) at the start of <code>self</code>.\nInsert <code>new_node</code> (defined in <code>defs</code>) at the end of <code>self</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nOutput values from this <code>ControlRegion</code>, provided to the ‚Ä¶\nOutputs from this <code>ControlNode</code>:\nIR transformations (typically whole-<code>Module</code>).\nInsert all of <code>list_to_prepend</code>‚Äôs nodes at the start of ‚Ä¶\nPretty-printing anything in the IR, from whole <code>Module</code>s to ‚Ä¶\n<code>QPtr</code>-related type definitions and passes.\nRegister a custom <code>ExtInstSetDesc</code> with name ‚Ä¶\nRemove <code>node</code> (defined in <code>defs</code>) from <code>self</code>.\nWhen <code>type_of_ptr_to</code> is <code>QPtr</code>, <code>shape</code> must be used to ‚Ä¶\nSPIR-V support, mainly conversions to/from SPIR-T (<code>lower</code>/‚Ä¶\nMutable IR traversal.\nThe type of a pointer to the global variable (as opposed ‚Ä¶\nThe unstructured (part of the) control-flow graph of the ‚Ä¶\nImmutable IR traversal.\nUnconditional branch to a single target.\nThe control-flow graph (CFG) of a function, as ‚Ä¶\nLeave the current invocation, similar to returning from ‚Ä¶\nLeave the current function, optionally returning a value.\nBranch to one of several targets, chosen by a single value ‚Ä¶\nControl-flow ‚Äústructurizer‚Äù, which attempts to convert ‚Ä¶\nReaching this point in the control-flow is undefined ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIterate over all <code>ControlRegion</code>s making up <code>func_def_body</code>‚Äô‚Ä¶\n<code>target_inputs[region][input_idx]</code> is the <code>Value</code> that ‚Ä¶\nAll blocks and ddefinitions they contain, which have to be ‚Ä¶\nIncremental tracker for definition uses (and CFG edges ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImmutable traversal (i.e. visiting) helper for ‚Ä¶\nMutable traversal (i.e. transforming) helper for ‚Ä¶\nReposition to <code>new_position</code>.\nReposition to <code>new_position</code>.\nDemote to a <code>FuncAt</code>, with the same <code>position</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmulate a ‚Äúreborrow‚Äù, which is automatic only for <code>&amp;mut</code> ‚Ä¶\nReturn the <code>Type</code> of this <code>Value</code> (<code>Context</code> used for ‚Ä¶\n<code>QPtr</code> transforms.\nApply the <code>cfg::Structurizer</code> algorithm to all function ‚Ä¶\nRemove exports which aren‚Äôt ‚Äúroots‚Äù (‚Ä¶\nRemap <code>Import::LinkName</code> to definitions exported as ‚Ä¶\nA <code>Print</code> <code>Output</code> type that splits the attributes from the ‚Ä¶\n‚ÄúDefinitions-before-uses‚Äù / ‚Äútopo-sorted‚Äù printing ‚Ä¶\nDefinition that typically looks like one of these cases:\nCreate a <code>Plan</code> with all of <code>module</code>‚Äôs contents.\nCreate a <code>Plan</code> with all of <code>root</code>‚Äôs dependencies, followed ‚Ä¶\nCreate a <code>Plan</code> that combines <code>Plan::for_root</code> from each ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrint the whole <code>Plan</code> to a <code>Versions&lt;pretty::Fragment&gt;</code> and ‚Ä¶\nLike <code>pretty_print</code>, but separately pretty-printing ‚Äúroot ‚Ä¶\nGet a <strong>memory</strong> <code>QPtr</code> pointing at the contents of the buffer ‚Ä¶\nGet the length of the buffer whose handle is (implicitly) ‚Ä¶\nUsed directly to access memory (e.g. <code>QPtrOp::Load</code>, ‚Ä¶\nAdjust a <strong>memory</strong> <code>QPtr</code> (<code>inputs[0]</code>), by adding a (signed) ‚Ä¶\nUsed as a common base for (dynamic) offsetting, which ‚Ä¶\nWhen applied to a <code>DataInst</code> with a <code>QPtr</code>-typed output value, ‚Ä¶\nAdjust a <strong>handle array</strong> <code>QPtr</code> (<code>inputs[0]</code>), by selecting the ‚Ä¶\nUsed to access one or more handles (i.e. optionally ‚Ä¶\nVarious toggles for layout-related behavior that is not ‚Ä¶\nRead a single value from a <code>QPtr</code> (<code>inputs[0]</code>).\nAdjust a <strong>memory</strong> <code>QPtr</code> (<code>inputs[0]</code>), by adding a (signed) ‚Ä¶\nUsed as a common base for (constant) offsetting, which ‚Ä¶\n<code>QPtr</code>-specific attributes ([<code>Attr::QPtr</code>]).\n<code>QPtr</code>-specific operations ([<code>DataInstKind::QPtr</code>]).\nWrite a single value (<code>inputs[1]</code>) to a <code>QPtr</code> (<code>inputs[0]</code>).\nUsed as a typed pointer (e.g. via unknown SPIR-V ‚Ä¶\nWhen applied to a <code>DataInst</code> with a <code>QPtr</code>-typed ‚Ä¶\nNot actually used, which could be caused by pointer ‚Ä¶\nWhen applied to a <code>QPtr</code>-typed <code>GlobalVar</code>, <code>DataInst</code>, ‚Ä¶\nAssumed size and alignment for <code>OpTypeBool</code>, even if unusable\n<code>QPtr</code> usage analysis (for legalizing/lifting).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>QPtr</code> lifting (e.g. to SPIR-V).\nAssumed size and alignment for logical <code>OpTypePointer</code>s, ‚Ä¶\n<code>QPtr</code> lowering (e.g. from SPIR-V).\nIf present, this is a worst-case upper bound on memory ‚Ä¶\nVariable shapes (untyped memory layouts vs abstract ‚Ä¶\nBounds on the dynamic ‚Äúindex‚Äù (<code>inputs[1]</code>).\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContext for lifting <code>QPtr</code>s to SPIR-V <code>OpTypePointer</code>s.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nContext for lowering SPIR-V <code>OpTypePointer</code>s to <code>QPtr</code>s.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBuffer resources, describing ranges of (technically) ‚Ä¶\n<code>GlobalVar</code>s are currently used for both chunks of plain ‚Ä¶\n‚ÄúAbstract resource‚Äù handle, that can be found in ‚Ä¶\nOne or more (i.e. optionally arrayed) ‚Äúabstract resource‚Ä¶\nUntyped memory shape with constant alignment but ‚Ä¶\nUntyped memory shape with constant alignment and size.\nFully opaque resources (e.g. samplers, images).\nNon-memory pipeline interface, which must keep the exact ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSemantic properties of a SPIR-V module (not tied to any ‚Ä¶\nSPIR-V ID.\nSPIR-V immediate (one word, longer immediates are a ‚Ä¶\nA SPIR-V instruction, in its minimal form (opcode and ‚Ä¶\nA full SPIR-V instruction (like <code>Inst</code>, but including ‚Ä¶\nNon-semantic details (i.e. debuginfo) of a SPIR-V module ‚Ä¶\nGiven a single <code>LiteralString</code> (as one <code>Imm::Short</code> or a ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSPIR-T to SPIR-V lifting.\nSPIR-V to SPIR-T lowering.\nPretty-printing SPIR-V operands.\nLow-level parsing of SPIR-V binary form.\nSPIR-V specification parsing/indexing.\nLow-level emission of SPIR-V binary form.\nAn inconsistency was detected in the operands to be ‚Ä¶\nUnprinted ID operand, of its original type (allowing ‚Ä¶\nThe smallest unit produced by printing a (‚Äúlogical‚Äù) ‚Ä¶\nAll the <code>Token</code>s outputted by printing one single (‚Äúlogical‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nGroup (ordered according to <code>opcode</code>) <code>imms</code> and <code>ids</code> into ‚Ä¶\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPrint a single SPIR-V operand from only immediates, ‚Ä¶\nReturns the argument unchanged.\nCopy of the header words (for convenience).\nCalls <code>U::from(self)</code>.\nSimplified information for pretty-printing ‚Äúextended ‚Ä¶\nSimplified <code>InstructionDef</code> for pretty-printing ‚Äúextended ‚Ä¶\nThe literal uses as many words as required by its type, ‚Ä¶\nThe literal is a word-encoded byte array, that ends with a ‚Ä¶\nWhether the trailing <code>*</code> ‚Äúoperand‚Äù (i.e. repeated ‚Ä¶\nThe literal is always one word (but may occupy only part ‚Ä¶\nReturn a (potentially infinite) iterator of <code>OperandKind</code>s, ‚Ä¶\nLike <code>all_operands</code>, but providing access to the operand ‚Ä¶\nReturn a (potentially infinite) iterator of <code>OperandKind</code>s, ‚Ä¶\nLike <code>all_params</code>, but providing access to the operand names ‚Ä¶\nLookup the definition for this opcode in the lazily-loaded ‚Ä¶\nLookup the definition for this operand kind in the ‚Ä¶\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturn a lazily-loaded <code>Spec</code> (only does significant work ‚Ä¶\nReturn a lazily-parsed <code>ExtInstSetDesc</code>, if a known one ‚Ä¶\nUtilities for indexing data in a variety of ways (names, ‚Ä¶\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this instruction is non-semantic debuginfo and ‚Ä¶\nUnpack this <code>PackedOperandNameAndKind</code> into just its ‚Ä¶\nLookup the name for this opcode in the lazily-loaded <code>Spec</code>.\nLookup the name for this operand kind in the lazily-loaded ‚Ä¶\nLookup the name &amp; definition for this opcode in the ‚Ä¶\nLookup the name &amp; definition for this operand kind in the ‚Ä¶\nUnpack this <code>PackedOperandNameAndKind</code> into a name and ‚Ä¶\nReturns an iterator of <code>BitIdx</code>s, from which <code>x</code> can be ‚Ä¶\nReturns <code>Some(BitIdx(i))</code> if and only if <code>x == (1 &lt;&lt; i)</code>.\nDeserialization for the <code>.grammar.json</code> files, without any ‚Ä¶\nShorter name to use during pretty-printing.\nLookup the name &amp; definition for <code>opcode</code> in the ‚Ä¶\nPre-cached IDs for ‚Äúwell-known‚Äù names.\nFlat array (<code>Vec</code>) storage, likely used with compact indices.\nLike <code>Flat</code>, but the <code>Vec</code> elements are wrapped in <code>Option</code>.\nSegmented sparse storage, taking advantage of Khronos‚Äô ‚Ä¶\nKhronos-oriented segmented sparse array (see <code>KhrSegmented</code>).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConstruct a <code>KhrSegmentedVec</code> out of an iterator with ‚Ä¶\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet an index from a name.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nOutput SPIR-V words.\nSome part of the original <code>T</code> value was transformed, and a ‚Ä¶\nLike <code>InnerTransform</code>, but only for the <code>in_place_transform_X</code> ‚Ä¶\nTrait implemented on ‚Äútransformable‚Äù types, to further ‚Ä¶\nThe result of a transformation (which is not in-place).\nThe original <code>T</code> value remains as it was, at no cost.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMap every element of an iterator through <code>transform_elem</code> ‚Ä¶\nDynamic dispatch version of <code>InnerVisit</code>.\nTrait implemented on ‚Äúdeeply visitable‚Äù types, to ‚Ä¶\nTrait implemented on ‚Äúvisitable‚Äù types (shallowly ‚Ä¶")