searchState.loadedDescShard("ruzstd", 0, "In a Zstandard frame, there’s a frame header, followed …\nStructures and utilities used for reading from data, …\nFramedecoder is the man struct users interact with to …\nFSE, short for Finite State Entropy, is an encoding …\nRe-exports of std values for when the std is available.\nBlock header definitions.\nUtilities and representations for the first half of a …\nUtilities and representations for the second half of a …\nA representation of a single block header. As well as …\nThere are 4 different kinds of blocks, and the type of …\nA Zstandard compressed block. <code>Block_Size</code> is the length of …\nA single byte, repeated <code>Block_Size</code> times (Run Length …\nAn uncompressed block.\nThis is not a valid block, and this value should not be …\nThe size of the block. If the block is BlockType::RLE, …\nThe size of the decompressed data. If the block type is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether this block is the last block in the frame. It may …\nThis is a standard Huffman-compressed block, starting with …\nA compressed block consists of two sections, a literals …\nThe way which a literal section is encoded.\nLiterals consist of a single byte value repeated …\nLiterals are stored uncompressed.\nThis is a Huffman-compressed block, using the Huffman tree …\nFor types LiteralsSectionType::Raw and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGiven the first byte of a header, determine the size of …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe type of the literal section.\nCreate a new LiteralsSection.\nThis value will be either 1 stream or 4 streams if the …\nParse the header into <code>self</code>, and returns the number of …\nIf this block is of type LiteralsSectionType::Raw, then …\nThis byte defines the compression mode of each symbol type\nStandard FSE compression, a distribution table will be …\nThe compression mode used for symbol compression\nA predefined FSE distribution table is used, and no …\nThe table consists of a single byte, which contains the …\nThe table used in the previous compressed block with at …\nA sequence represents potentially redundant data, and it …\nDeserialize a two bit mode value into a ModeType\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLiteral length, or the number of bytes to be copied from …\nRead the compression mode of the literal lengths field.\nThe length of the match to make during the match copy step.\nRead the compression mode of the match lengths field.\nCreate a new SequencesHeader.\nHow far back to go in the decompressed data to read from …\nRead the compression mode of the offset value field.\nAttempt to deserialize the provided buffer into <code>self</code>, …\nThis module contains the decompress_literals function, …\nStructures that wrap around various decoders to make …\nInteract with a provided source at a bit level.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nZstandard encodes some types of data in a way that the …\nHow many bits are left to read by the reader.\nReturns the argument unchanged.\nRead <code>n</code> number of bits from the source. Will read at most …\nSame as calling get_bits three times but slightly more …\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new BlockDecoder.\nCheck if and how many bytes can currently be drawn from …\ndrain the buffer completely\nDrain as much as possible while retaining enough so that …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nZstandard includes support for “raw content” …\nThis 4 byte (little endian) magic number refers to the …\nParses the dictionary from <code>raw</code> and set the tables it …\nThe content of a dictionary acts as a “past” in front …\nReturns the argument unchanged.\nReturns the argument unchanged.\nA dictionary can contain an entropy table, either FSE or …\nA dictionary can contain an entropy table, either FSE or …\nA 4 byte value used by decoders to check if they can use …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe 3 most recent offsets are stored so that they can be …\nDecode and decompress the provided literals section into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA block level decoding buffer.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe decoder used for FSE blocks.\nThe decoder used for Huffman blocks.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake the provided decoder and execute the sequences stored …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\n“The maximum allowed accuracy log for literals length …\n“The maximum allowed accuracy log for literals length …\n“The maximum accuracy log for the offset table is 8.”\nDecode the provided source as a series of sequences into …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nZstandard compressed data is made of one or more Frames. …\nThe first byte is called the <code>Frame Header Descriptor</code>, and …\nA frame header has a variable size, with a minimum of 2 …\nThis magic number is included at the start of a single …\nThe maximum window size is 3.75TB\nThe minimum window size is defined as 1 KB\nIf this flag is set, a 32 bit <code>Content_Checksum</code> will be …\nThis is a two bit flag telling if a dictionary ID is …\nThe ID (if provided) of the dictionary required to decode …\nRead the size of the <code>Dictionary_ID</code> field from the frame …\nObtain the uncompressed size (in bytes) of the frame …\nRead the size of the <code>Frame_Content_size</code> field from the …\nRead the <code>Frame_Content_Size_flag</code> from the frame header …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRead a single serialized frame from the reader and return …\nThis bit is reserved for some future feature, a compliant …\nIf this flag is set, data must be regenerated within a …\nRead the size of the window from the header, returning the …\nThis implements a decoder for zstd frames.\nAdd a dict to the FrameDecoder that can be used when …\nCounter for how many blocks have already been decoded\nCounter for how many bytes have been consumed while …\nHow many bytes can currently be collected from the …\nCollect bytes and retain window_size bytes while decoding …\nCollect bytes and retain window_size bytes while decoding …\nReturns how many bytes the frame contains after …\nDecode multiple frames into the output slice.\nDecode multiple frames into the extra capacity of the …\nDecodes blocks from a reader. It requires that the …\nDecodes as many blocks as possible from the source slice …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the checksum that was calculated while decoding. …\nReturns the checksum that was read from the data. Only …\ninit() will allocate all needed buffers if it is the first …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWhether the current frames last block has been decoded yet …\nThis will create a new decoder without allocating anything …\nreset() will allocate all needed buffers if it is the …\nA single entry in an FSE table.\nFSE decoding involves a decoding table that describes the …\nThe size of the table is stored in logarithm base 2 format,\nThis value is used as an offset value, and it is added to …\nreturns how many BYTEs (not bits) were read while building …\nGiven the provided accuracy log, build a decoding table …\nThe actual table containing the decoded symbol and the …\nReturns the byte associated with the symbol the internal …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize internal state and prepare for decoding. After …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInitialize a new empty Finite State Entropy decoding table.\nInitialize a new Finite State Entropy decoder.\nHow many bits should be read from the stream when decoding …\nReset <code>self</code> and update <code>self</code>’s state to mirror the …\nEmpty the table and clear all internal state.\nAn FSE state value represents an index in the FSE table.\nThe byte that should be put in the decode output when …\nIn this context, probability refers to the likelihood that …\nAdvance the internal state to decode the next symbol in …\nA single entry in the table contains the decoded …\nAn interface around a huffman table used to decode data.\nRead from <code>source</code> and parse it into a huffman table.\nDecode the symbol the internal state (cursor) is pointed …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize internal state and prepare to decode data. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe maximum size in bits a prefix code in the encoded data …\nCreate a new, empty table.\nCreate a new decoder with the provided table\nAdvance the internal cursor to the next symbol. After …\nCompletely empty the table then repopulate as a replica of …\nCompletely empty the table of all data.\nRe-initialize the decoder, using the new table if one is …\nState is used to index into the table.\nA socket address could not be bound because the address is …\nA nonexistent interface was requested or the requested …\nAn entity already exists, often a file.\nProgram argument list too long.\nThe operation failed because a pipe was closed.\nThe connection was aborted (terminated) by the remote …\nThe connection was refused by the remote server.\nThe connection was reset by the remote server.\nCross-device or cross-filesystem (hard) link or rename.\nDeadlock (avoided).\nA non-empty directory was specified where an empty …\nThe error type for I/O operations of the <code>Read</code>, <code>Write</code>, <code>Seek</code>…\nA list specifying general categories of I/O error.\nExecutable file is busy.\nFile larger than allowed or supported.\nLoop in the filesystem or IO subsystem; often, too many …\nFilesystem quota was exceeded.\nThe remote host is not reachable.\nThe operation was partially successful and needs to be …\nThis operation was interrupted.\nData not valid for the operation were encountered.\nA filename was invalid.\nA parameter was incorrect.\nThe filesystem object is, unexpectedly, a directory.\nThe system’s networking is down.\nThe network containing the remote host is not reachable.\nA filesystem object is, unexpectedly, not a directory.\nThe network operation failed because it was not connected …\nAn entity was not found, often a file.\nSeek on unseekable file.\nA custom error that does not fall under any other I/O …\nAn operation could not be completed, because it failed to …\nThe operation lacked the necessary privileges to complete.\nThe <code>Read</code> trait allows for reading bytes from a source.\nThe filesystem or storage medium is read-only, but a write …\nResource is busy.\nStale network file handle.\nThe underlying storage (typically, a filesystem) is full.\nThe I/O operation’s timeout expired, causing it to be …\nToo many (hard) links to the same filesystem object.\nAn error returned when an operation could not be completed …\nThis operation is unsupported on this platform.\nThe operation needs to block to complete, but the blocking …\nA trait for objects which are byte-oriented sinks.\nAn error returned when an operation could not be completed …\nCreates a “by reference” adaptor for this instance of …\nCreates a “by reference” adapter for this instance of …\nTransforms this <code>Read</code> instance to an <code>Iterator</code> over its …\nCreates an adapter which will chain this stream with …\nAttempts to downcast the custom boxed error to <code>E</code>.\nFlushes this output stream, ensuring that all …\nShows a human-readable description of the <code>ErrorKind</code>.\nConverts a <code>alloc::ffi::NulError</code> into a <code>Error</code>.\nConverts <code>TryReserveError</code> to an error with …\nConverts an <code>ErrorKind</code> into an <code>Error</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new instance of an <code>Error</code> from a particular OS …\nReturns a mutable reference to the inner error wrapped by …\nReturns a reference to the inner error wrapped by this …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConsumes the <code>Error</code>, returning its inner error (if any).\nDetermines if this <code>Read</code>er has an efficient <code>read_vectored</code> …\nDetermines if this <code>Write</code>r has an efficient <code>write_vectored</code> …\nReturns the corresponding <code>ErrorKind</code> for this error.\nReturns an error representing the last OS error which …\nCreates a new I/O error from a known kind of error as well …\nCreates a new I/O error from an arbitrary error payload.\nReturns the OS error that this error represents (if any).\nPull some bytes from this source into the specified …\nPull some bytes from this source into the specified buffer.\nReads the exact number of bytes required to fill <code>cursor</code>.\nReads the exact number of bytes required to fill <code>buf</code>.\nReads all bytes until EOF in this source, placing them …\nReads all bytes until EOF in this source, appending them …\nLike <code>read</code>, except that it reads into a slice of buffers.\nCreates an adapter which will read at most <code>limit</code> bytes …\nWrites a buffer into this writer, returning how many bytes …\nAttempts to write an entire buffer into this writer.\nAttempts to write multiple buffers into this writer.\nWrites a formatted string into this writer, returning any …\nLike <code>write</code>, except that it writes from a slice of buffers.\nHigh level Zstandard frame decoder that can be used to …\nReturns the argument unchanged.\nGets a mutable reference to the underlying reader.\nGets a reference to the underlying reader.\nCalls <code>U::from(self)</code>.\nDestructures this object into the inner FrameDecoder.\nDestructures this object into the inner reader.\nDestructures this object into both the inner reader and …")