<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `Passes` enum in crate `spirv_tools`."><title>Passes in spirv_tools::opt - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../static.files/rustdoc-42caa33d.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="spirv_tools" data-themes="" data-resource-suffix="" data-rustdoc-version="1.84.0-nightly (b19329a37 2024-11-21)" data-channel="nightly" data-search-js="search-92e6798f.js" data-settings-js="settings-0f613d39.js" ><script src="../../static.files/storage-59e33391.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-044be391.svg"></head><body class="rustdoc enum"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../spirv_tools/index.html">spirv_<wbr>tools</a><span class="version">0.10.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Passes</a></h2><h3><a href="#variants">Variants</a></h3><ul class="block variant"><li><a href="#variant.AggressiveDCE" title="AggressiveDCE">AggressiveDCE</a></li><li><a href="#variant.AmdExtToKhr" title="AmdExtToKhr">AmdExtToKhr</a></li><li><a href="#variant.BlockMerge" title="BlockMerge">BlockMerge</a></li><li><a href="#variant.CFGCleanup" title="CFGCleanup">CFGCleanup</a></li><li><a href="#variant.CodeSinking" title="CodeSinking">CodeSinking</a></li><li><a href="#variant.CombineAccessChains" title="CombineAccessChains">CombineAccessChains</a></li><li><a href="#variant.CompactIds" title="CompactIds">CompactIds</a></li><li><a href="#variant.ConditionalConstantPropagation" title="ConditionalConstantPropagation">ConditionalConstantPropagation</a></li><li><a href="#variant.ConvertRelaxedToHalf" title="ConvertRelaxedToHalf">ConvertRelaxedToHalf</a></li><li><a href="#variant.CopyPropagateArrays" title="CopyPropagateArrays">CopyPropagateArrays</a></li><li><a href="#variant.DeadBranchElim" title="DeadBranchElim">DeadBranchElim</a></li><li><a href="#variant.DeadInsertElim" title="DeadInsertElim">DeadInsertElim</a></li><li><a href="#variant.DeadVariableElimination" title="DeadVariableElimination">DeadVariableElimination</a></li><li><a href="#variant.DescriptorScalarReplacement" title="DescriptorScalarReplacement">DescriptorScalarReplacement</a></li><li><a href="#variant.EliminateDeadConstant" title="EliminateDeadConstant">EliminateDeadConstant</a></li><li><a href="#variant.EliminateDeadFunctions" title="EliminateDeadFunctions">EliminateDeadFunctions</a></li><li><a href="#variant.EliminateDeadMembers" title="EliminateDeadMembers">EliminateDeadMembers</a></li><li><a href="#variant.FixStorageClass" title="FixStorageClass">FixStorageClass</a></li><li><a href="#variant.FlattenDecoration" title="FlattenDecoration">FlattenDecoration</a></li><li><a href="#variant.FoldSpecConstantOpAndComposite" title="FoldSpecConstantOpAndComposite">FoldSpecConstantOpAndComposite</a></li><li><a href="#variant.FreezeSpecConstantValue" title="FreezeSpecConstantValue">FreezeSpecConstantValue</a></li><li><a href="#variant.GraphicsRobustAccess" title="GraphicsRobustAccess">GraphicsRobustAccess</a></li><li><a href="#variant.IfConversion" title="IfConversion">IfConversion</a></li><li><a href="#variant.InlineExhaustive" title="InlineExhaustive">InlineExhaustive</a></li><li><a href="#variant.InlineOpaque" title="InlineOpaque">InlineOpaque</a></li><li><a href="#variant.InsertExtractElim" title="InsertExtractElim">InsertExtractElim</a></li><li><a href="#variant.InterpolateFixup" title="InterpolateFixup">InterpolateFixup</a></li><li><a href="#variant.LocalAccessChainConvert" title="LocalAccessChainConvert">LocalAccessChainConvert</a></li><li><a href="#variant.LocalMultiStoreElim" title="LocalMultiStoreElim">LocalMultiStoreElim</a></li><li><a href="#variant.LocalRedundancyElimination" title="LocalRedundancyElimination">LocalRedundancyElimination</a></li><li><a href="#variant.LocalSingleBlockLoadStoreElim" title="LocalSingleBlockLoadStoreElim">LocalSingleBlockLoadStoreElim</a></li><li><a href="#variant.LocalSingleStoreElim" title="LocalSingleStoreElim">LocalSingleStoreElim</a></li><li><a href="#variant.LoopInvariantCodeMotion" title="LoopInvariantCodeMotion">LoopInvariantCodeMotion</a></li><li><a href="#variant.LoopPeeling" title="LoopPeeling">LoopPeeling</a></li><li><a href="#variant.LoopUnswitch" title="LoopUnswitch">LoopUnswitch</a></li><li><a href="#variant.MergeReturn" title="MergeReturn">MergeReturn</a></li><li><a href="#variant.Null" title="Null">Null</a></li><li><a href="#variant.PrivateToLocal" title="PrivateToLocal">PrivateToLocal</a></li><li><a href="#variant.PropagateLineInfo" title="PropagateLineInfo">PropagateLineInfo</a></li><li><a href="#variant.ReduceLoadSize" title="ReduceLoadSize">ReduceLoadSize</a></li><li><a href="#variant.RedundancyElimination" title="RedundancyElimination">RedundancyElimination</a></li><li><a href="#variant.RedundantLineInfoElim" title="RedundantLineInfoElim">RedundantLineInfoElim</a></li><li><a href="#variant.RelaxFloatOps" title="RelaxFloatOps">RelaxFloatOps</a></li><li><a href="#variant.RemoveDuplicates" title="RemoveDuplicates">RemoveDuplicates</a></li><li><a href="#variant.RemoveUnusedInterfaceVariables" title="RemoveUnusedInterfaceVariables">RemoveUnusedInterfaceVariables</a></li><li><a href="#variant.ReplaceInvalidOpcode" title="ReplaceInvalidOpcode">ReplaceInvalidOpcode</a></li><li><a href="#variant.SSARewrite" title="SSARewrite">SSARewrite</a></li><li><a href="#variant.Simplification" title="Simplification">Simplification</a></li><li><a href="#variant.StrengthReduction" title="StrengthReduction">StrengthReduction</a></li><li><a href="#variant.StripDebugInfo" title="StripDebugInfo">StripDebugInfo</a></li><li><a href="#variant.StripNonSemanticInfo" title="StripNonSemanticInfo">StripNonSemanticInfo</a></li><li><a href="#variant.UnifyConstant" title="UnifyConstant">UnifyConstant</a></li><li><a href="#variant.UpgradeMemoryModel" title="UpgradeMemoryModel">UpgradeMemoryModel</a></li><li><a href="#variant.VectorDCE" title="VectorDCE">VectorDCE</a></li><li><a href="#variant.Workaround1209" title="Workaround1209">Workaround1209</a></li><li><a href="#variant.WrapOpKill" title="WrapOpKill">WrapOpKill</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Passes" title="Clone">Clone</a></li><li><a href="#impl-Copy-for-Passes" title="Copy">Copy</a></li><li><a href="#impl-Debug-for-Passes" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-Freeze-for-Passes" title="Freeze">Freeze</a></li><li><a href="#impl-RefUnwindSafe-for-Passes" title="RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Passes" title="Send">Send</a></li><li><a href="#impl-Sync-for-Passes" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-Passes" title="Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Passes" title="UnwindSafe">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-CloneToUninit-for-T" title="CloneToUninit">CloneToUninit</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-ToOwned-for-T" title="ToOwned">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In spirv_<wbr>tools::<wbr>opt</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../index.html">spirv_tools</a>::<wbr><a href="index.html">opt</a></span><h1>Enum <span class="enum">Passes</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../src/spirv_tools_sys/opt.rs.html#14">Source</a> </span></div><pre class="rust item-decl"><code><div class="code-attribute">#[repr(C)]</div>pub enum Passes {
<details class="toggle type-contents-toggle"><summary class="hideme"><span>Show 56 variants</span></summary>    AggressiveDCE = 0,
    AmdExtToKhr = 1,
    BlockMerge = 2,
    ConditionalConstantPropagation = 3,
    CFGCleanup = 4,
    CodeSinking = 5,
    CombineAccessChains = 6,
    CompactIds = 7,
    ConvertRelaxedToHalf = 8,
    CopyPropagateArrays = 9,
    DeadBranchElim = 10,
    DeadInsertElim = 11,
    DeadVariableElimination = 12,
    DescriptorScalarReplacement = 13,
    EliminateDeadConstant = 14,
    EliminateDeadFunctions = 15,
    EliminateDeadMembers = 16,
    FixStorageClass = 17,
    FlattenDecoration = 18,
    FoldSpecConstantOpAndComposite = 19,
    FreezeSpecConstantValue = 20,
    GraphicsRobustAccess = 21,
    IfConversion = 22,
    InlineExhaustive = 23,
    InlineOpaque = 24,
    InsertExtractElim = 25,
    InterpolateFixup = 26,
    LocalAccessChainConvert = 27,
    LocalMultiStoreElim = 28,
    LocalRedundancyElimination = 29,
    LocalSingleBlockLoadStoreElim = 30,
    LocalSingleStoreElim = 31,
    LoopInvariantCodeMotion = 32,
    LoopPeeling = 33,
    LoopUnswitch = 34,
    MergeReturn = 35,
    Null = 36,
    PrivateToLocal = 37,
    PropagateLineInfo = 38,
    ReduceLoadSize = 39,
    RedundancyElimination = 40,
    RedundantLineInfoElim = 41,
    RelaxFloatOps = 42,
    RemoveDuplicates = 43,
    RemoveUnusedInterfaceVariables = 44,
    ReplaceInvalidOpcode = 45,
    Simplification = 46,
    SSARewrite = 47,
    StrengthReduction = 48,
    StripDebugInfo = 49,
    StripNonSemanticInfo = 50,
    UnifyConstant = 51,
    UpgradeMemoryModel = 52,
    VectorDCE = 53,
    Workaround1209 = 54,
    WrapOpKill = 55,
</details>}</code></pre><h2 id="variants" class="variants section-header">Variants<a href="#variants" class="anchor">§</a></h2><div class="variants"><section id="variant.AggressiveDCE" class="variant"><a href="#variant.AggressiveDCE" class="anchor">§</a><h3 class="code-header">AggressiveDCE = 0</h3></section><div class="docblock"><p>Create aggressive dead code elimination pass
This pass eliminates unused code from the module. In addition,
it detects and eliminates code which may have spurious uses but which do
not contribute to the output of the function. The most common cause of
such code sequences is summations in loops whose result is no longer used
due to dead code elimination. This optimization has additional compile
time cost over standard dead code elimination.</p>
<p>This pass only processes entry point functions. It also only processes
shaders with relaxed logical addressing (see opt/instruction.h). It
currently will not process functions with function calls. Unreachable
functions are deleted.</p>
<p>This pass will be made more effective by first running passes that remove
dead control flow and inlines function calls.</p>
<p>This pass can be especially useful after running Local Access Chain
Conversion, which tends to cause cycles of dead code to be left after
Store/Load elimination passes are completed. These cycles cannot be
eliminated with standard dead code elimination.</p>
</div><section id="variant.AmdExtToKhr" class="variant"><a href="#variant.AmdExtToKhr" class="anchor">§</a><h3 class="code-header">AmdExtToKhr = 1</h3></section><div class="docblock"><p>Replaces the extensions VK_AMD_shader_ballot,VK_AMD_gcn_shader, and
VK_AMD_shader_trinary_minmax with equivalent code using core instructions and
capabilities.</p>
</div><section id="variant.BlockMerge" class="variant"><a href="#variant.BlockMerge" class="anchor">§</a><h3 class="code-header">BlockMerge = 2</h3></section><div class="docblock"><p>Creates a block merge pass.
This pass searches for blocks with a single Branch to a block with no
other predecessors and merges the blocks into a single block. Continue
blocks and Merge blocks are not candidates for the second block.</p>
<p>The pass is most useful after Dead Branch Elimination, which can leave
such sequences of blocks. Merging them makes subsequent passes more
effective, such as single block local store-load elimination.</p>
<p>While this pass reduces the number of occurrences of this sequence, at
this time it does not guarantee all such sequences are eliminated.</p>
<p>Presence of phi instructions can inhibit this optimization. Handling
these is left for future improvements.</p>
</div><section id="variant.ConditionalConstantPropagation" class="variant"><a href="#variant.ConditionalConstantPropagation" class="anchor">§</a><h3 class="code-header">ConditionalConstantPropagation = 3</h3></section><div class="docblock"><p>Creates a conditional constant propagation (CCP) pass.
This pass implements the SSA-CCP algorithm in</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> Constant propagation with conditional branches,
 Wegman and Zadeck, ACM TOPLAS <span class="number">13</span>(<span class="number">2</span>):<span class="number">181</span>-<span class="number">210.</span></code></pre></div>
<p>Constant values in expressions and conditional jumps are folded and
simplified. This may reduce code size by removing never executed jump targets
and computations with constant operands.</p>
</div><section id="variant.CFGCleanup" class="variant"><a href="#variant.CFGCleanup" class="anchor">§</a><h3 class="code-header">CFGCleanup = 4</h3></section><div class="docblock"><p>Creates a CFG cleanup pass.
This pass removes cruft from the control flow graph of functions that are
reachable from entry points and exported functions. It currently includes the
following functionality:</p>
<ul>
<li>Removal of unreachable basic blocks.</li>
</ul>
</div><section id="variant.CodeSinking" class="variant"><a href="#variant.CodeSinking" class="anchor">§</a><h3 class="code-header">CodeSinking = 5</h3></section><div class="docblock"><p>Create a pass to do code sinking.  Code sinking is a transformation
where an instruction is moved into a more deeply nested construct.</p>
</div><section id="variant.CombineAccessChains" class="variant"><a href="#variant.CombineAccessChains" class="anchor">§</a><h3 class="code-header">CombineAccessChains = 6</h3></section><div class="docblock"><p>Create a pass to combine chained access chains.
This pass looks for access chains fed by other access chains and combines
them into a single instruction where possible.</p>
</div><section id="variant.CompactIds" class="variant"><a href="#variant.CompactIds" class="anchor">§</a><h3 class="code-header">CompactIds = 7</h3></section><div class="docblock"><p>Creates a compact ids pass.
The pass remaps result ids to a compact and gapless range starting from %1.</p>
</div><section id="variant.ConvertRelaxedToHalf" class="variant"><a href="#variant.ConvertRelaxedToHalf" class="anchor">§</a><h3 class="code-header">ConvertRelaxedToHalf = 8</h3></section><div class="docblock"><p>Create pass to convert relaxed precision instructions to half precision.
This pass converts as many relaxed float32 arithmetic operations to half as
possible. It converts any float32 operands to half if needed. It converts
any resulting half precision values back to float32 as needed. No variables
are changed. No image operations are changed.</p>
<p>Best if run after function scope store/load and composite operation
eliminations are run. Also best if followed by instruction simplification,
redundancy elimination and DCE.</p>
</div><section id="variant.CopyPropagateArrays" class="variant"><a href="#variant.CopyPropagateArrays" class="anchor">§</a><h3 class="code-header">CopyPropagateArrays = 9</h3></section><div class="docblock"><p>Create copy propagate arrays pass.
This pass looks to copy propagate memory references for arrays.  It looks
for specific code patterns to recognize array copies.</p>
</div><section id="variant.DeadBranchElim" class="variant"><a href="#variant.DeadBranchElim" class="anchor">§</a><h3 class="code-header">DeadBranchElim = 10</h3></section><div class="docblock"><p>Create dead branch elimination pass.
For each entry point function, this pass will look for SelectionMerge
BranchConditionals with constant condition and convert to a Branch to
the indicated label. It will delete resulting dead blocks.</p>
<p>For all phi functions in merge block, replace all uses with the id
corresponding to the living predecessor.</p>
<p>Note that some branches and blocks may be left to avoid creating invalid
control flow. Improving this is left to future work.</p>
<p>This pass is most effective when preceeded by passes which eliminate
local loads and stores, effectively propagating constant values where
possible.</p>
</div><section id="variant.DeadInsertElim" class="variant"><a href="#variant.DeadInsertElim" class="anchor">§</a><h3 class="code-header">DeadInsertElim = 11</h3></section><div class="docblock"><p>Creates a dead insert elimination pass.
This pass processes each entry point function in the module, searching for
unreferenced inserts into composite types. These are most often unused
stores to vector components. They are unused because they are never
referenced, or because there is another insert to the same component between
the insert and the reference. After removing the inserts, dead code
elimination is attempted on the inserted values.</p>
<p>This pass performs best after access chains are converted to inserts and
extracts and local loads and stores are eliminated. While executing this
pass can be advantageous on its own, it is also advantageous to execute
this pass after CreateInsertExtractPass() as it will remove any unused
inserts created by that pass.</p>
</div><section id="variant.DeadVariableElimination" class="variant"><a href="#variant.DeadVariableElimination" class="anchor">§</a><h3 class="code-header">DeadVariableElimination = 12</h3></section><div class="docblock"><p>Create dead variable elimination pass.
This pass will delete module scope variables, along with their decorations,
that are not referenced.</p>
</div><section id="variant.DescriptorScalarReplacement" class="variant"><a href="#variant.DescriptorScalarReplacement" class="anchor">§</a><h3 class="code-header">DescriptorScalarReplacement = 13</h3></section><div class="docblock"><p>Create descriptor scalar replacement pass.
This pass replaces every array variable |desc| that has a DescriptorSet and
Binding decorations with a new variable for each element of the array.
Suppose |desc| was bound at binding |b|.  Then the variable corresponding to
|desc[i]| will have binding |b+i|.  The descriptor set will be the same.  It
is assumed that no other variable already has a binding that will used by one
of the new variables.  If not, the pass will generate invalid Spir-V.  All
accesses to |desc| must be OpAccessChain instructions with a literal index
for the first index.</p>
</div><section id="variant.EliminateDeadConstant" class="variant"><a href="#variant.EliminateDeadConstant" class="anchor">§</a><h3 class="code-header">EliminateDeadConstant = 14</h3></section><div class="docblock"><p>Creates a eliminate-dead-constant pass.
A eliminate-dead-constant pass removes dead constants, including normal
contants defined by OpConstant, OpConstantComposite, OpConstantTrue, or
OpConstantFalse and spec constants defined by OpSpecConstant,
OpSpecConstantComposite, OpSpecConstantTrue, OpSpecConstantFalse or
OpSpecConstantOp.</p>
</div><section id="variant.EliminateDeadFunctions" class="variant"><a href="#variant.EliminateDeadFunctions" class="anchor">§</a><h3 class="code-header">EliminateDeadFunctions = 15</h3></section><div class="docblock"><p>Creates an eliminate-dead-functions pass.
An eliminate-dead-functions pass will remove all functions that are not in
the call trees rooted at entry points and exported functions.  These
functions are not needed because they will never be called.</p>
</div><section id="variant.EliminateDeadMembers" class="variant"><a href="#variant.EliminateDeadMembers" class="anchor">§</a><h3 class="code-header">EliminateDeadMembers = 16</h3></section><div class="docblock"><p>Creates an eliminate-dead-members pass.
An eliminate-dead-members pass will remove all unused members of structures.
This will not affect the data layout of the remaining members.</p>
</div><section id="variant.FixStorageClass" class="variant"><a href="#variant.FixStorageClass" class="anchor">§</a><h3 class="code-header">FixStorageClass = 17</h3></section><div class="docblock"><p>Create a pass to fix incorrect storage classes.  In order to make code
generation simpler, DXC may generate code where the storage classes do not
match up correctly.  This pass will fix the errors that it can.</p>
</div><section id="variant.FlattenDecoration" class="variant"><a href="#variant.FlattenDecoration" class="anchor">§</a><h3 class="code-header">FlattenDecoration = 18</h3></section><div class="docblock"><p>Creates a flatten-decoration pass.
A flatten-decoration pass replaces grouped decorations with equivalent
ungrouped decorations.  That is, it replaces each OpDecorationGroup
instruction and associated OpGroupDecorate and OpGroupMemberDecorate
instructions with equivalent OpDecorate and OpMemberDecorate instructions.
The pass does not attempt to preserve debug information for instructions
it removes.</p>
</div><section id="variant.FoldSpecConstantOpAndComposite" class="variant"><a href="#variant.FoldSpecConstantOpAndComposite" class="anchor">§</a><h3 class="code-header">FoldSpecConstantOpAndComposite = 19</h3></section><div class="docblock"><p>Creates a fold-spec-constant-op-and-composite pass.
A fold-spec-constant-op-and-composite pass folds spec constants defined by
OpSpecConstantOp or OpSpecConstantComposite instruction, to normal Constants
defined by OpConstantTrue, OpConstantFalse, OpConstant, OpConstantNull, or
OpConstantComposite instructions. Note that spec constants defined with
OpSpecConstant, OpSpecConstantTrue, or OpSpecConstantFalse instructions are
not handled, as these instructions indicate their value are not determined
and can be changed in future. A spec constant is foldable if all of its
value(s) can be determined from the module. E.g., an integer spec constant
defined with OpSpecConstantOp instruction can be folded if its value won’t
change later. This pass will replace the original OpSpecContantOp instruction
with an OpConstant instruction. When folding composite spec constants,
new instructions may be inserted to define the components of the composite
constant first, then the original spec constants will be replaced by
OpConstantComposite instructions.</p>
<p>There are some operations not supported yet:
OpSConvert, OpFConvert, OpQuantizeToF16 and
all the operations under Kernel capability.
TODO(qining): Add support for the operations listed above.</p>
</div><section id="variant.FreezeSpecConstantValue" class="variant"><a href="#variant.FreezeSpecConstantValue" class="anchor">§</a><h3 class="code-header">FreezeSpecConstantValue = 20</h3></section><div class="docblock"><p>Creates a freeze-spec-constant-value pass.
A freeze-spec-constant pass specializes the value of spec constants to
their default values. This pass only processes the spec constants that have
SpecId decorations (defined by OpSpecConstant, OpSpecConstantTrue, or
OpSpecConstantFalse instructions) and replaces them with their normal
counterparts (OpConstant, OpConstantTrue, or OpConstantFalse). The
corresponding SpecId annotation instructions will also be removed. This
pass does not fold the newly added normal constants and does not process
other spec constants defined by OpSpecConstantComposite or
OpSpecConstantOp.</p>
</div><section id="variant.GraphicsRobustAccess" class="variant"><a href="#variant.GraphicsRobustAccess" class="anchor">§</a><h3 class="code-header">GraphicsRobustAccess = 21</h3></section><div class="docblock"><p>Creates a graphics robust access pass.</p>
<p>This pass injects code to clamp indexed accesses to buffers and internal
arrays, providing guarantees satisfying Vulkan’s robustBufferAccess rules.</p>
<p>TODO(dneto): Clamps coordinates and sample index for pointer calculations
into storage images (OpImageTexelPointer).  For an cube array image, it
assumes the maximum layer count times 6 is at most 0xffffffff.</p>
<p>NOTE: This pass will fail with a message if:</p>
<ul>
<li>The module is not a Shader module.</li>
<li>The module declares VariablePointers, VariablePointersStorageBuffer, or
RuntimeDescriptorArrayEXT capabilities.</li>
<li>The module uses an addressing model other than Logical</li>
<li>Access chain indices are wider than 64 bits.</li>
<li>Access chain index for a struct is not an OpConstant integer or is out
of range. (The module is already invalid if that is the case.)</li>
<li>TODO(dneto): The OpImageTexelPointer coordinate component is not 32-bits
wide.</li>
</ul>
<p>NOTE: Access chain indices are always treated as signed integers.  So
if an array has a fixed size of more than 2^31 elements, then elements
from 2^31 and above are never accessible with a 32-bit index,
signed or unsigned.  For this case, this pass will clamp the index
between 0 and at 2^31-1, inclusive.
Similarly, if an array has more then 2^15 element and is accessed with
a 16-bit index, then elements from 2^15 and above are not accessible.
In this case, the pass will clamp the index between 0 and 2^15-1
inclusive.</p>
</div><section id="variant.IfConversion" class="variant"><a href="#variant.IfConversion" class="anchor">§</a><h3 class="code-header">IfConversion = 22</h3></section><div class="docblock"><p>Creates a pass that converts if-then-else like assignments into OpSelect.</p>
</div><section id="variant.InlineExhaustive" class="variant"><a href="#variant.InlineExhaustive" class="anchor">§</a><h3 class="code-header">InlineExhaustive = 23</h3></section><div class="docblock"><p>Creates an exhaustive inline pass.
An exhaustive inline pass attempts to exhaustively inline all function
calls in all functions in an entry point call tree. The intent is to enable,
albeit through brute force, analysis and optimization across function
calls by subsequent optimization passes. As the inlining is exhaustive,
there is no attempt to optimize for size or runtime performance. Functions
that are not in the call tree of an entry point are not changed.</p>
</div><section id="variant.InlineOpaque" class="variant"><a href="#variant.InlineOpaque" class="anchor">§</a><h3 class="code-header">InlineOpaque = 24</h3></section><div class="docblock"><p>Creates an opaque inline pass.
An opaque inline pass inlines all function calls in all functions in all
entry point call trees where the called function contains an opaque type
in either its parameter types or return type. An opaque type is currently
defined as Image, Sampler or SampledImage. The intent is to enable, albeit
through brute force, analysis and optimization across these function calls
by subsequent passes in order to remove the storing of opaque types which is
not legal in Vulkan. Functions that are not in the call tree of an entry
point are not changed.</p>
</div><section id="variant.InsertExtractElim" class="variant"><a href="#variant.InsertExtractElim" class="anchor">§</a><h3 class="code-header">InsertExtractElim = 25</h3></section><div class="docblock"><p>Creates an insert/extract elimination pass.
This pass processes each entry point function in the module, searching for
extracts on a sequence of inserts. It further searches the sequence for an
insert with indices identical to the extract. If such an insert can be
found before hitting a conflicting insert, the extract’s result id is
replaced with the id of the values from the insert.</p>
<p>Besides removing extracts this pass enables subsequent dead code elimination
passes to delete the inserts. This pass performs best after access chains are
converted to inserts and extracts and local loads and stores are eliminated.</p>
</div><section id="variant.InterpolateFixup" class="variant"><a href="#variant.InterpolateFixup" class="anchor">§</a><h3 class="code-header">InterpolateFixup = 26</h3></section><div class="docblock"><p>Replaces the internal version of GLSLstd450 InterpolateAt* extended
instructions with the externally valid version. The internal version allows
an OpLoad of the interpolant for the first argument. This pass removes the
OpLoad and replaces it with its pointer. glslang and possibly other
frontends will create the internal version for HLSL. This pass will be part
of HLSL legalization and should be called after interpolants have been
propagated into their final positions.</p>
</div><section id="variant.LocalAccessChainConvert" class="variant"><a href="#variant.LocalAccessChainConvert" class="anchor">§</a><h3 class="code-header">LocalAccessChainConvert = 27</h3></section><div class="docblock"><p>Creates a local access chain conversion pass.
A local access chain conversion pass identifies all function scope
variables which are accessed only with loads, stores and access chains
with constant indices. It then converts all loads and stores of such
variables into equivalent sequences of loads, stores, extracts and inserts.</p>
<p>This pass only processes entry point functions. It currently only converts
non-nested, non-ptr access chains. It does not process modules with
non-32-bit integer types present. Optional memory access options on loads
and stores are ignored as we are only processing function scope variables.</p>
<p>This pass unifies access to these variables to a single mode and simplifies
subsequent analysis and elimination of these variables along with their
loads and stores allowing values to propagate to their points of use where
possible.</p>
</div><section id="variant.LocalMultiStoreElim" class="variant"><a href="#variant.LocalMultiStoreElim" class="anchor">§</a><h3 class="code-header">LocalMultiStoreElim = 28</h3></section><div class="docblock"><p>Creates an SSA local variable load/store elimination pass.
For every entry point function, eliminate all loads and stores of function
scope variables only referenced with non-access-chain loads and stores.
Eliminate the variables as well.</p>
<p>The presence of access chain references and function calls can inhibit
the above optimization.</p>
<p>Only shader modules with relaxed logical addressing (see opt/instruction.h)
are currently processed. Currently modules with any extensions enabled are
not processed. This is left for future work.</p>
<p>This pass is most effective if preceeded by Inlining and
LocalAccessChainConvert. LocalSingleStoreElim and LocalSingleBlockElim
will reduce the work that this pass has to do.</p>
</div><section id="variant.LocalRedundancyElimination" class="variant"><a href="#variant.LocalRedundancyElimination" class="anchor">§</a><h3 class="code-header">LocalRedundancyElimination = 29</h3></section><div class="docblock"><p>Create value numbering pass.
This pass will look for instructions in the same basic block that compute the
same value, and remove the redundant ones.</p>
</div><section id="variant.LocalSingleBlockLoadStoreElim" class="variant"><a href="#variant.LocalSingleBlockLoadStoreElim" class="anchor">§</a><h3 class="code-header">LocalSingleBlockLoadStoreElim = 30</h3></section><div class="docblock"><p>Creates a single-block local variable load/store elimination pass.
For every entry point function, do single block memory optimization of
function variables referenced only with non-access-chain loads and stores.
For each targeted variable load, if previous store to that variable in the
block, replace the load’s result id with the value id of the store.
If previous load within the block, replace the current load’s result id
with the previous load’s result id. In either case, delete the current
load. Finally, check if any remaining stores are useless, and delete store
and variable if possible.</p>
<p>The presence of access chain references and function calls can inhibit
the above optimization.</p>
<p>Only modules with relaxed logical addressing (see opt/instruction.h) are
currently processed.</p>
<p>This pass is most effective if preceeded by Inlining and
LocalAccessChainConvert. This pass will reduce the work needed to be done
by LocalSingleStoreElim and LocalMultiStoreElim.</p>
<p>Only functions in the call tree of an entry point are processed.</p>
</div><section id="variant.LocalSingleStoreElim" class="variant"><a href="#variant.LocalSingleStoreElim" class="anchor">§</a><h3 class="code-header">LocalSingleStoreElim = 31</h3></section><div class="docblock"><p>Creates a local single store elimination pass.
For each entry point function, this pass eliminates loads and stores for
function scope variable that are stored to only once, where possible. Only
whole variable loads and stores are eliminated; access-chain references are
not optimized. Replace all loads of such variables with the value that is
stored and eliminate any resulting dead code.</p>
<p>Currently, the presence of access chains and function calls can inhibit this
pass, however the Inlining and LocalAccessChainConvert passes can make it
more effective. In additional, many non-load/store memory operations are
not supported and will prohibit optimization of a function. Support of
these operations are future work.</p>
<p>Only shader modules with relaxed logical addressing (see opt/instruction.h)
are currently processed.</p>
<p>This pass will reduce the work needed to be done by LocalSingleBlockElim
and LocalMultiStoreElim and can improve the effectiveness of other passes
such as DeadBranchElimination which depend on values for their analysis.</p>
</div><section id="variant.LoopInvariantCodeMotion" class="variant"><a href="#variant.LoopInvariantCodeMotion" class="anchor">§</a><h3 class="code-header">LoopInvariantCodeMotion = 32</h3></section><div class="docblock"><p>Create LICM pass.
This pass will look for invariant instructions inside loops and hoist them to
the loops preheader.</p>
</div><section id="variant.LoopPeeling" class="variant"><a href="#variant.LoopPeeling" class="anchor">§</a><h3 class="code-header">LoopPeeling = 33</h3></section><div class="docblock"><p>Creates a loop peeling pass.
This pass will look for conditions inside a loop that are true or false only
for the N first or last iteration. For loop with such condition, those N
iterations of the loop will be executed outside of the main loop.
To limit code size explosion, the loop peeling can only happen if the code
size growth for each loop is under |code_growth_threshold|.</p>
</div><section id="variant.LoopUnswitch" class="variant"><a href="#variant.LoopUnswitch" class="anchor">§</a><h3 class="code-header">LoopUnswitch = 34</h3></section><div class="docblock"><p>Creates a loop unswitch pass.
This pass will look for loop independent branch conditions and move the
condition out of the loop and version the loop based on the taken branch.
Works best after LICM and local multi store elimination pass.</p>
</div><section id="variant.MergeReturn" class="variant"><a href="#variant.MergeReturn" class="anchor">§</a><h3 class="code-header">MergeReturn = 35</h3></section><div class="docblock"><p>create merge return pass.
changes functions that have multiple return statements so they have a single
return statement.</p>
<p>for structured control flow it is assumed that the only unreachable blocks in
the function are trivial merge and continue blocks.</p>
<p>a trivial merge block contains the label and an opunreachable instructions,
nothing else.  a trivial continue block contain a label and an opbranch to
the header, nothing else.</p>
<p>these conditions are guaranteed to be met after running dead-branch
elimination.</p>
</div><section id="variant.Null" class="variant"><a href="#variant.Null" class="anchor">§</a><h3 class="code-header">Null = 36</h3></section><div class="docblock"><p>Creates a null pass.
A null pass does nothing to the SPIR-V module to be optimized.</p>
</div><section id="variant.PrivateToLocal" class="variant"><a href="#variant.PrivateToLocal" class="anchor">§</a><h3 class="code-header">PrivateToLocal = 37</h3></section><div class="docblock"><p>Create a private to local pass.
This pass looks for variables delcared in the private storage class that are
used in only one function.  Those variables are moved to the function storage
class in the function that they are used.</p>
</div><section id="variant.PropagateLineInfo" class="variant"><a href="#variant.PropagateLineInfo" class="anchor">§</a><h3 class="code-header">PropagateLineInfo = 38</h3></section><div class="docblock"><p>Create line propagation pass
This pass propagates line information based on the rules for OpLine and
OpNoline and clones an appropriate line instruction into every instruction
which does not already have debug line instructions.</p>
<p>This pass is intended to maximize preservation of source line information
through passes which delete, move and clone instructions. Ideally it should
be run before any such pass. It is a bookend pass with EliminateDeadLines
which can be used to remove redundant line instructions at the end of a
run of such passes and reduce final output file size.</p>
</div><section id="variant.ReduceLoadSize" class="variant"><a href="#variant.ReduceLoadSize" class="anchor">§</a><h3 class="code-header">ReduceLoadSize = 39</h3></section><div class="docblock"><p>Create a pass to reduce the size of loads.
This pass looks for loads of structures where only a few of its members are
used.  It replaces the loads feeding an OpExtract with an OpAccessChain and
a load of the specific elements.</p>
</div><section id="variant.RedundancyElimination" class="variant"><a href="#variant.RedundancyElimination" class="anchor">§</a><h3 class="code-header">RedundancyElimination = 40</h3></section><div class="docblock"><p>Create global value numbering pass.
This pass will look for instructions where the same value is computed on all
paths leading to the instruction.  Those instructions are deleted.</p>
</div><section id="variant.RedundantLineInfoElim" class="variant"><a href="#variant.RedundantLineInfoElim" class="anchor">§</a><h3 class="code-header">RedundantLineInfoElim = 41</h3></section><div class="docblock"><p>Create dead line elimination pass
This pass eliminates redundant line instructions based on the rules for
OpLine and OpNoline. Its main purpose is to reduce the size of the file
need to store the SPIR-V without losing line information.</p>
<p>This is a bookend pass with PropagateLines which attaches line instructions
to every instruction to preserve line information during passes which
delete, move and clone instructions. DeadLineElim should be run after
PropagateLines and all such subsequent passes. Normally it would be one
of the last passes to be run.</p>
</div><section id="variant.RelaxFloatOps" class="variant"><a href="#variant.RelaxFloatOps" class="anchor">§</a><h3 class="code-header">RelaxFloatOps = 42</h3></section><div class="docblock"><p>Create relax float ops pass.
This pass decorates all float32 result instructions with RelaxedPrecision
if not already so decorated.</p>
</div><section id="variant.RemoveDuplicates" class="variant"><a href="#variant.RemoveDuplicates" class="anchor">§</a><h3 class="code-header">RemoveDuplicates = 43</h3></section><div class="docblock"><p>Creates a remove duplicate pass.
This pass removes various duplicates:</p>
<ul>
<li>duplicate capabilities;</li>
<li>duplicate extended instruction imports;</li>
<li>duplicate types;</li>
<li>duplicate decorations.</li>
</ul>
</div><section id="variant.RemoveUnusedInterfaceVariables" class="variant"><a href="#variant.RemoveUnusedInterfaceVariables" class="anchor">§</a><h3 class="code-header">RemoveUnusedInterfaceVariables = 44</h3></section><div class="docblock"><p>Creates a remove-unused-interface-variables pass.
Removes variables referenced on the |OpEntryPoint| instruction that are not
referenced in the entry point function or any function in its call tree.
Note that this could cause the shader interface to no longer match other
shader stages.</p>
</div><section id="variant.ReplaceInvalidOpcode" class="variant"><a href="#variant.ReplaceInvalidOpcode" class="anchor">§</a><h3 class="code-header">ReplaceInvalidOpcode = 45</h3></section><div class="docblock"><p>Creates a pass that will replace instructions that are not valid for the
current shader stage by constants.  Has no effect on non-shader modules.</p>
</div><section id="variant.Simplification" class="variant"><a href="#variant.Simplification" class="anchor">§</a><h3 class="code-header">Simplification = 46</h3></section><div class="docblock"><p>Creates a pass that simplifies instructions using the instruction folder.</p>
</div><section id="variant.SSARewrite" class="variant"><a href="#variant.SSARewrite" class="anchor">§</a><h3 class="code-header">SSARewrite = 47</h3></section><div class="docblock"><p>Create the SSA rewrite pass.
This pass converts load/store operations on function local variables into
operations on SSA IDs.  This allows SSA optimizers to act on these variables.
Only variables that are local to the function and of supported types are
processed (see IsSSATargetVar for details).</p>
</div><section id="variant.StrengthReduction" class="variant"><a href="#variant.StrengthReduction" class="anchor">§</a><h3 class="code-header">StrengthReduction = 48</h3></section><div class="docblock"><p>Creates a strength-reduction pass.
A strength-reduction pass will look for opportunities to replace an
instruction with an equivalent and less expensive one.  For example,
multiplying by a power of 2 can be replaced by a bit shift.</p>
</div><section id="variant.StripDebugInfo" class="variant"><a href="#variant.StripDebugInfo" class="anchor">§</a><h3 class="code-header">StripDebugInfo = 49</h3></section><div class="docblock"><p>Creates a strip-debug-info pass.
A strip-debug-info pass removes all debug instructions (as documented in
Section 3.32.2 of the SPIR-V spec) of the SPIR-V module to be optimized.</p>
</div><section id="variant.StripNonSemanticInfo" class="variant"><a href="#variant.StripNonSemanticInfo" class="anchor">§</a><h3 class="code-header">StripNonSemanticInfo = 50</h3></section><div class="docblock"><p>Creates a strip-nonsemantic-info pass.
A strip-nonsemantic-info pass removes all reflections and explicitly
non-semantic instructions.</p>
</div><section id="variant.UnifyConstant" class="variant"><a href="#variant.UnifyConstant" class="anchor">§</a><h3 class="code-header">UnifyConstant = 51</h3></section><div class="docblock"><p>Creates a unify-constant pass.
A unify-constant pass de-duplicates the constants. Constants with the exact
same value and identical form will be unified and only one constant will
be kept for each unique pair of type and value.
There are several cases not handled by this pass:</p>
<ol>
<li>Constants defined by OpConstantNull instructions (null constants) and
constants defined by OpConstantFalse, OpConstant or OpConstantComposite
with value 0 (zero-valued normal constants) are not considered equivalent.
So null constants won’t be used to replace zero-valued normal constants,
vice versa.</li>
<li>Whenever there are decorations to the constant’s result id id, the
constant won’t be handled, which means, it won’t be used to replace any
other constants, neither can other constants replace it.</li>
<li>NaN in float point format with different bit patterns are not unified.</li>
</ol>
</div><section id="variant.UpgradeMemoryModel" class="variant"><a href="#variant.UpgradeMemoryModel" class="anchor">§</a><h3 class="code-header">UpgradeMemoryModel = 52</h3></section><div class="docblock"><p>Create a pass to upgrade to the VulkanKHR memory model.
This pass upgrades the Logical GLSL450 memory model to Logical VulkanKHR.
Additionally, it modifies memory, image, atomic and barrier operations to
conform to that model’s requirements.</p>
</div><section id="variant.VectorDCE" class="variant"><a href="#variant.VectorDCE" class="anchor">§</a><h3 class="code-header">VectorDCE = 53</h3></section><div class="docblock"><p>Create a vector dce pass.
This pass looks for components of vectors that are unused, and removes them
from the vector.  Note this would still leave around lots of dead code that
a pass of ADCE will be able to remove.</p>
</div><section id="variant.Workaround1209" class="variant"><a href="#variant.Workaround1209" class="anchor">§</a><h3 class="code-header">Workaround1209 = 54</h3></section><div class="docblock"><p>Creates a workaround driver bugs pass.  This pass attempts to work around
a known driver bug (issue #1209) by identifying the bad code sequences and
rewriting them.</p>
<p>Current workaround: Avoid OpUnreachable instructions in loops.</p>
</div><section id="variant.WrapOpKill" class="variant"><a href="#variant.WrapOpKill" class="anchor">§</a><h3 class="code-header">WrapOpKill = 55</h3></section><div class="docblock"><p>Create a pass to replace each OpKill instruction with a function call to a
function that has a single OpKill.  Also replace each OpTerminateInvocation
instruction  with a function call to a function that has a single
OpTerminateInvocation.  This allows more code to be inlined.</p>
</div></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Passes" class="impl"><a class="src rightside" href="../../src/spirv_tools_sys/opt.rs.html#11">Source</a><a href="#impl-Clone-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../../src/spirv_tools_sys/opt.rs.html#11">Source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#174">Source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: &amp;Self)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Passes" class="impl"><a class="src rightside" href="../../src/spirv_tools_sys/opt.rs.html#11">Source</a><a href="#impl-Debug-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../src/spirv_tools_sys/opt.rs.html#11">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Error.html" title="struct core::fmt::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><section id="impl-Copy-for-Passes" class="impl"><a class="src rightside" href="../../src/spirv_tools_sys/opt.rs.html#11">Source</a><a href="#impl-Copy-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-Passes" class="impl"><a href="#impl-Freeze-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section><section id="impl-RefUnwindSafe-for-Passes" class="impl"><a href="#impl-RefUnwindSafe-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section><section id="impl-Send-for-Passes" class="impl"><a href="#impl-Send-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section><section id="impl-Sync-for-Passes" class="impl"><a href="#impl-Sync-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section><section id="impl-Unpin-for-Passes" class="impl"><a href="#impl-Unpin-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section><section id="impl-UnwindSafe-for-Passes" class="impl"><a href="#impl-UnwindSafe-for-Passes" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="enum" href="enum.Passes.html" title="enum spirv_tools::opt::Passes">Passes</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-CloneToUninit-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#273">Source</a><a href="#impl-CloneToUninit-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html" title="trait core::clone::CloneToUninit">CloneToUninit</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone_to_uninit" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#275">Source</a><a href="#method.clone_to_uninit" class="anchor">§</a><h4 class="code-header">unsafe fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit" class="fn">clone_to_uninit</a>(&amp;self, dst: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>)</h4></section></summary><span class="item-info"><div class="stab unstable"><span class="emoji">🔬</span><span>This is a nightly-only experimental API. (<code>clone_to_uninit</code>)</span></div></span><div class='docblock'>Performs copy-assignment from <code>self</code> to <code>dst</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.CloneToUninit.html#tymethod.clone_to_uninit">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#765">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#768">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#748-750">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#758">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#82-84">Source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86">Source</a><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#87">Source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#91">Source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#805-807">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#809">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#812">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#790-792">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#794">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#797">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div></section></div></main></body></html>