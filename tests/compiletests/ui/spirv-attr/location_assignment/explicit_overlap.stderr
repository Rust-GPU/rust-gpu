OpCapability Shader
OpMemoryModel Logical Simple
OpEntryPoint Vertex %1 "main" %2 %3
OpName %5 "spirv_std::glam::Mat4"
OpMemberName %5 0 "x_axis"
OpMemberName %5 1 "y_axis"
OpMemberName %5 2 "z_axis"
OpMemberName %5 3 "w_axis"
OpName %2 "out1"
OpName %3 "out2"
OpDecorate %2 Location 0
OpDecorate %3 Location 1
%6 = OpTypeFloat 32
%7 = OpTypeVector %6 4
%5 = OpTypeStruct %7 %7 %7 %7
%8 = OpTypePointer Output %5
%9 = OpTypeVector %6 2
%10 = OpTypePointer Output %9
%11 = OpTypeVoid
%12 = OpTypeFunction %11
%2 = OpVariable  %8  Output
%13 = OpConstant  %6  1
%14 = OpConstant  %6  0
%15 = OpConstantComposite  %7  %13 %14 %14 %14
%16 = OpConstantComposite  %7  %14 %13 %14 %14
%17 = OpConstantComposite  %7  %14 %14 %13 %14
%18 = OpConstantComposite  %7  %14 %14 %14 %13
%19 = OpConstantComposite  %5  %15 %16 %17 %18
%20 = OpTypePointer Output %6
%3 = OpVariable  %10  Output
%21 = OpTypeInt 32 0
%22 = OpConstant  %21  0
%23 = OpConstant  %21  1
%1 = OpFunction  %11  None %12
%24 = OpLabel
OpStore %2 %19
%25 = OpInBoundsAccessChain  %20  %3 %22
OpStore %25 %14
%26 = OpInBoundsAccessChain  %20  %3 %23
OpStore %26 %14
OpNoLine
OpReturn
OpFunctionEnd
error: Output variable `out2` at location 1 conflicts with another variable
  --> $DIR/explicit_overlap.rs:24:53
   |
LL | pub fn main(#[spirv(location = 0)] out1: &mut Mat4, #[spirv(location = 1)] out2: &mut Vec2) {
   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
note: variable `out1` already uses location 1 component 0
  --> $DIR/explicit_overlap.rs:24:13
   |
LL | pub fn main(#[spirv(location = 0)] out1: &mut Mat4, #[spirv(location = 1)] out2: &mut Vec2) {
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   = help: `out1` is at location 0 but type `spirv_std::glam::Mat4` consumes 4 locations (0â€“3)
   = note: spirv-val failed
   = note: module `<normalized>`

error: aborting due to 1 previous error

